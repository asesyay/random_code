def filter_postings_by_returns_sku_batched(engine, df_postings, sku_batch=2000):
    """
    Берёт уникальные RezonItemId из df_postings, проверяет их на возврат в Dim_ExemplarInfo,
    и оставляет в df_postings только строки со SKU, у которых PostingIsReturn=TRUE.
    """
    if df_postings.empty:
        return df_postings

    skus = sorted(df_postings["RezonItemId"].dropna().astype(str).unique())
    if not skus:
        return df_postings.iloc[0:0].copy()

    dfs = []
    for part in chunks(skus, sku_batch):
        sku_sql = ",".join(f"'{x}'" for x in part)
        sql = SQL_RETURN_SKU_BY_LIST.format(sku_list=sku_sql)
        df = pd.read_sql(sa.text(sql), engine)
        dfs.append(df)
        log(f"return-SKU batch: sku={len(part)}, matched={len(df)}")

    df_return_sku = pd.concat(dfs, ignore_index=True).drop_duplicates() if dfs else pd.DataFrame(columns=["SKU"])
    if df_return_sku.empty:
        log("no return SKUs matched; result is empty")
        return df_postings.iloc[0:0].copy()

    df_return_sku["SKU"] = df_return_sku["SKU"].astype(str)
    # локальный inner-merge
    out = df_postings.merge(df_return_sku.rename(columns={"SKU": "RezonItemId"}), on="RezonItemId", how="inner")
    # для удобства флаг (все строки уже TRUE)
    out["PostingIsReturn"] = True
    log("postings after return filter:", len(out))
    return out
